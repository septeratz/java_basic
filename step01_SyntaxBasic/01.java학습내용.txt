*instance: 메모리에 생성된 사용 가능한 실체화된 객체
 

[1] 변수
1. 선언 위치 기준으로 구분
	1) 멤버 변수
		- 객체 구성 요소
		- class {} 내부에 선언
		- heap 저장
		- 객체 생성 시점에 생성, 객체가 메모리에서 소멸될 때 삭제
		
		세부적 구분
		1. static 변수
			- 객체 생성과 무관하게 사용 가능한 변수
			- 메모리에 실제로 생성되는 시점?
		2. instance 변수
			- 객체 생성이 필요한 변수
		
	2) 로컬 변수
		- 메소드, 생성자(), {} 내에 생성되는 변수
		- stack 저장
		- 호출 시 생성, 종료 시 자동 소멸(반환)
	
2. 데이터 타입
	1) 기본 타입(원시 타입)
		- 8가지
	2) 참조 타입(객체, reference 변수)
		- 무한대
		- class 기반으로 생성되는 타입
		- 생성 문법: 타입 변수명 = new 생성자();
	
[2] 생성자
- 주 목적: 객체 생성 시 호출되는 구성 요소
- 특징: class에 하나 이상 반드시 존재해야 함
	개발자가 작성하지 않아도 자동으로 기본 생성자가 생성됨
- 문법:
	- argument와 {}가 필수적으로 있어야 함
	- class명과 100% 일치해야 함
	class class명 {
		class명() { 
		}
	}	
	
[3] static
1. 선언 위치
	변수: static 타입 변수명 [=값];
		- byte code가 저장되는 시점에 자동 생성
		- method 영역에 실체화되어 있음, 기본값으로 초기화도 진행
		- 생성되는 모든 객체가 공유하는 데이터 변수
		
	메소드: static 반환타입 메소드 ([..]) {[...]}
		- 객체 생성 없이도 메소드를 호출할 수 있는 유일한 방법
		- 호출 문법: class명.메소드([..]);
			public void static main(String[] args) { 
			}
			
		
	static{}

2. static 메소드
- 객체 생성없이 클래스명으로 메소드 호출 가능
	동일한 클래스 내의 static 메소드 호출 시에는 class명 생략 가능
- java.lang.Math
	- 제공받은 라이브러리, API
	- 모든 메소드는 static, 유일한 두 변수는 불변값 final 상수
	- 메소드 호출 시 객체 생성 의미가 없음
	즉, 모든 메소드는 static이고, 접근자도 final이며, 생성자를 private로 만들어서 객체 생성 및 상속을 막아놓음
		
	
- static 적합 여부?
	예1. String 메소드 내 존재하는 메소드 
		1) public int length(){ return 문자열 객체 길이값 }
		2) public static int length(){ return 문자열 객체 길이값 }
			// 객체 생성 여부에 상관없이 호출 가능해야 하므로 논리적으로 잘못됨
		3) public static int length(String data){ return 문자열 객체 길이값 }
		
		String data = "fisa"; // 문자열 객체 생성 시 자동 생성
		System.out.println(data.length()); // 4 출력
		System.out.println(String.length()); // 가능은 한데 null값이므로 0
	
	예2. 문자열을 받아서 정수로 변환
		- 단, 알파벳과 동일하게 생긴 숫자 모양의 문자열에 한해서만
		- 호출시마다 값이 변경될 예정
		
		public int parseInt(String data) {
			return 받은 데이터 정수를 int로 반환해서
		}
		- 이 메소드의 기능 관점에선 이 메소드를 보유한 클래스 기반의 객체 생성의 의미가 있는가?
		-> 객체 생성이 굳이 필요 없음. static이 어울림
		
3. 접근 제한자
	1) public - class, 변수, 생성자, 메소드
	2) protected - 변수, 생성자, 메소드
	3) default(생략됨) - class, 변수, 생성자, 메소드
	4) private - 변수, 생성자, 메소드
	
4. 웹 서버에 객체 수를 강제적으로 조율해야 하는 상황
- 실행 perfomance를 위한 조치
- 의미없는 객체 생성 강제 금지
- 개발 방법
	경우의 수 1) 생성자 호출을 제약: private 생성자 선언
	경우의 수 2) 모든 메소드를 static해서 객체 생성 금지
	경우의 수 3) 객체 하나만 생성 보장 후에 일반 instance 메소드들 개발 및 제공
		-> singleton 디자인 패턴
		- step02_pattern 프로젝트에서 실습
			1. pattern 개발
			2. maven 의존 관리 tool
				- lombok : 코드 다이어트 라이브러리

					
5. 외부 라이브러리 환경 세팅 필수 도구들
	- 기능: 라이브러리 이름과 버전만 명확하면 어딘가에 있는 원격지로부터 관련된 모든 라이브러리 다운 가능
	- 의존관계 라이브러리 세팅 도구
		: Maven & Gradle
		: ide 등에 plugin으로 내장되어 있음
		
6. 팀단위 미션
- 주 목적: review
- 제약사항: log 기록 library 사용해서 콘솔창에 로그 기록하기
- 다른 1팀과 교류해서 피드백 필수,,,,,,,,,,친목도모,,리뷰,,발표안함....
- 프로젝트명: step03_mission
- 소요 시간: 4시간(~17:30)

개인별 점수 갱신
개인별 최고 기록
전체 랭킹
